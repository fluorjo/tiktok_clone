2.2.

translate 파일, theme파일 , mvc 구조 설계 등을 벌써부터 알려고 할 필요 없다. 이게 왜 유용한지 알 수 없다 지금 단계에선. 너무 그러다 보면 짜증나고 동기부여도 저하... 지금 내 상태가 좀 그런 듯. 

문제점들에 많이 부딪혀봐야 해결책들의 존재 이유를 알 수 있다. 

라이브러리의 필요성 역시 실수와 문제를 통해 알게 된다. 
특정 디자인 패턴 구조가 다른 것보다 왜 좋은지 등등도...

층을 쌓아가며 작업을 한다. 

UI를 먼저 만든다 

->데이터라는 층을 쌓는다. 일단 가짜 데이터를 막 넣어본 다음 진짜 데이터를 사용한다. 
->그 위에 firebase라는 층을 쌓는다. 

4.0.
- 빨간 글씨랑 노란 밑줄 나오는 이유?
widget들이 scaffold 내부에 없는 채로 넣어졌을 때 일어남. scaffold가 텍스트 디자인 같은 걸 설정하는 역할도 함.
- 따라서 컨테이너 대신 scaffold를 쓰고 위젯들을 그 안에 꼭 넣어줘야 함. 
- safe area = 그 내부에 있는 것들을 특정 공간에 있도록 보장함. 그리고 그 공간은 다른 거(상태 바 같은)에 가려지지 않음.

4.1.
- Navigator.of(context).push(MaterialPageRoute(
      builder: (context) => const SignUpScreen(),
  - push는 화면을 기존 화면 위에 계속 쌓는 것. 
  그래서 폰에서 뒤로가기하면 전 화면으로 돌아감. 
  - pop은 네비게이터의 가장 상단에 있는 화면, 즉 유저가 보고 있는 현재 화면을 스택에서 제거할 수 있음. 자료구조에서 스택의 push pop 떠올리면 됨. 
- feature-driven architecture
화면이 아닌 기능 중심으로 폴더 구조를 만드는 것. 
- FractionallySizedBox =부모 크기에 비례해서 박스 크기를 정하게 해주는 위젯. 이 단계에서는 버튼의 부모는 컬럼.

4.2.

- 페키지 설치 후 디버그 세션 재시작하는 습관 들이는 게 좋음.
-  final FaIcon icon; 
  <-폰트 어썸 아이콘을 icon 매개변수 선언.
- 중앙정렬 상태에서 한 요소만 위치 바꾸기 하는 방법 한 가지.
  expanded 사용=row나 컬럼에서 사용할 수 있는 만큼 공간을 전부 차지하는 위젯.
  자식(Child)이 사용 가능한 공간을 채우도록 행(Row), 열(Column) 또는 유연한영역(Flex)의 자식을 확장하는 위젯.
  근데 이 강의에서는 이건 쓰진 않음.
- stack = 위젯들을 서로 겹쳐서 보여줄 수 있는 위젯. 레이어 쌓는다는 느낌.
  Align = stack에 있는 위젯 중 하나의 정렬만 바꿀 수 있게 해준다. 

4.3.
- build 메서드에는 ui 코드만 넣고 함수는 따로 작성해서 불러오는 게 낫다. 코드 깔끔하게 하기 위해서. 
- 위젯의 생명주기와 연관된 메서드들은 _ 를 붙이지 않는다. 예를 들어 build나 dispose.

4.5.
- 컨트롤러를 dispose=제거 한다. 이벤트리스너를 추가하기 때문. 위젯이 사라질 때 컨트롤러와 그와 연관된 이벤트리스너까지 다 메모리에서 지우기 위해. 
- 어차피 잊어버려도 메모리 부족해서 앱에 crash 생김.
- 나중에 비디오 컨트롤러도 적절히 dispose 해야 함. 
- ★super.initState()를 모든 것의 앞에 선언했듯, super.dispose() 는 맨 뒤에 선언해준다. 
- form button이라고 따로 만들고, 플러터에 있는 textbutton 위젯 안 쓰는 이유? 이 편이 디자인하기에 더 쉽고 빠름. 
- onNextTap으로 이동시킬 때 다른 때와 달리 void onNextTap(BuildContext context) 하는 식으로 context 받지 않는 이유? usernamescreen은 statefulwidget이라 그 안의 state에 있다면 어디서든 context를 사용할 수 있기 때문. 그래서 context를 안 넘겨줘도 된다. 
- 조건문 
  void onNextTap() {
    if (_username.isEmpty) return;
    Navigator.of(context)
        .push(MaterialPageRoute(builder: (context) => const EmailScreen()));
  }
  그냥 이렇게만 써줘도 된다. else 따로 안 써줘도. 

4.9.
- 글로벌 키 : 고유 식별자 같은 역할을 함. & 폼의 state에 접근 가능. &폼의 메서드 실행 가능. 
- validator의 반환값은 string? . ?인 이유는 항상 반환하는 게 아니기 때문. 에러가 있을 때만 반환. 
- validate = bool 반환. 에러가 없으면 true, 있으면 false 반환. 